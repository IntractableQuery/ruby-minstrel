h1. Ruby Minstrel

Minstrel allows you to wrap every method call for a given class so you can more
easily observe how a class and its methods are being used.

h2. Get it

* gem install minstrel
* or download versions here: http://rubygems.org/gems/minstrel
* or github: https://github.com/jordansissel/ruby-minstrel

h2. Why?

Fun. Also, sometimes ruby-prof and similar tools are overkill when I am trying
to debug or dig into how a piece of code works.

It's a lot like strace/tcpdump/dtrace for ruby, or aims to be, anyway.

h2. Examples

h3. From the commandline

You can use minstrel to wrap classes with a default 'print' wrapper that simply
prints what is called.  For example:

<pre>
% RUBY_INSTRUMENT=String ruby -rminstrel -e 'puts "hello world".capitalize.reverse'
enter String#capitalize([])
exit String#capitalize([])
enter String#reverse([])
exit String#reverse([])
dlrow olleH
</pre>

h3. The 'minstrel' tool

Since this doesn't work as expected in ruby 1.8 (or maybe all rubies): ruby
-rrubygems -rminstrel ..., I provide 'minstrel' as a way to run ruby programs
with minstrel preloaded.

<pre>
% cat test.rb                            
#!/usr/bin/env ruby
puts "hello world".capitalize.reverse

% RUBY_INSTRUMENT=String minstrel test.rb
enter String#capitalize([])
exit String#capitalize([])
enter String#reverse([])
exit String#reverse([])
dlrow olleH
</pre>

h3. From ruby

Boilerplate:

<pre>
require "minstrel"

instrument = Minstrel::Instrument.new()
instrument.wrap(String) do |point, klass, method, *args|
  #  * point is either :enter or :exit depending if this function is about to be
  #    called or has finished being called.
  #  * klass is the class object (String, etc)
  #  * method is the method (a Symbol)
  #  * *args is the arguments passed
end
</pre>

Example:

<pre>
require "minstrel"

class Foo
  def bar(one, &block)
    yield one
  end
  
  def baz
    puts "Baz!"
  end 
end

instrument = Minstrel::Instrument.new
instrument.wrap(Foo) do |point, klass, method, *args|
  puts "#{point} #{klass.name}##{method}(#{args.inspect})"
end

foo = Foo.new
foo.bar(123) { |arg| puts arg }
foo.baz
</pre>

Output:

<pre>
enter Foo#bar([123])
123
exit Foo#bar([123])
enter Foo#baz([])
Baz!
exit Foo#baz([])
</pre>

h3. From ruby (deferred loading)

Sometimes you don't know when a class is going to be defined. To solve this,
you must use Minstrel::Instrument#wrap_classname. For example:

<pre>
>> require "minstrel"
>> Minstrel::Instrument.new.wrap_classname("TCPSocket")
>> require "socket"
Wrap of TCPSocket successful
</pre>

Minstrel will wrap 'require' and check for classes you want wrapped at each
require until it finds all the classes you asked to be wrapped.
